# JVM

## 一、内存模型

### 1、函数运行的过程中，JVM发生了什么事情？

**方法调用过程：**

- 除非被调用的方法是类方法，每一次方法调用指令之前，JVM先会把方法被调用的对象引用压入操作数栈中，除了对象的引用之外，JVM还会把方法的参数依次压入操作数栈。
- 在执行方法调用指令时，JVM会将函数参数和对象引用依次从操作数栈弹出，并新建一个栈帧，把对象引用和函数参数分别放入新栈帧的局部变量表slot0，1，2…。
- JVM把新栈帧push入虚拟机方法栈，并把PC指向函数的第一条待执行的指令。

JVM里面提供了**4条方法调用字节码指令**。分别如下：

invokestatic:调用静态方法
invokespecial:调用实例构造器<init>方法、私有方法和父类方法（super(),super.method()）
invokevirtual:调用所有的虚方法(静态方法、私有方法、实例构造器、父类方法、final方法都是非虚方法)
invokeinterface:调用接口方法，会在运行时期再确定一个实现此接口的对象

**动态分派**
当JVM遇到invokevirtual或invokeinterface时，需要运行时根据方法的符号引用查找到方法地址。具体过程如下：

1. 在方法调用指令之前，需要将对象的引用压入操作数栈
2. 在执行方法调用时，找到操作数栈顶的第一个元素所指向的对象实际类型，记作C
3. 在类型C中找到与常量池中的描述符和方法名称都相符的方法，并校验访问权限。如果找到该方法并通过校验，则返回这个方法的引用；
4. 否则，按照继承关系往上查找方法并校验访问权限；
5. 如果始终没找到方法，则抛出java.lang.AbstractMethodError异常；

可以看到，JVM是通过继承关系从子类往上查找的对应的方法的，为了提高动态分派时方法查找的效率，JVM为每个类都维护一个虚函数表。

## 二、对象引用

### 1、四种引用方式

[参考](https://blog.csdn.net/u014532217/article/details/79184412)

