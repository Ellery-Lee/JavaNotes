# JVM

## 一、内存模型

### 1、函数运行的过程中，JVM发生了什么事情？

**方法调用过程：**

- 除非被调用的方法是类方法，每一次方法调用指令之前，JVM先会把方法被调用的对象引用压入操作数栈中，除了对象的引用之外，JVM还会把方法的参数依次压入操作数栈。
- 在执行方法调用指令时，JVM会将函数参数和对象引用依次从操作数栈弹出，并新建一个栈帧，把对象引用和函数参数分别放入新栈帧的局部变量表slot0，1，2…。
- JVM把新栈帧push入虚拟机方法栈，并把PC指向函数的第一条待执行的指令。

JVM里面提供了**4条方法调用字节码指令**。分别如下：

invokestatic:调用静态方法
invokespecial:调用实例构造器<init>方法、私有方法和父类方法（super(),super.method()）
invokevirtual:调用所有的虚方法(静态方法、私有方法、实例构造器、父类方法、final方法都是非虚方法)
invokeinterface:调用接口方法，会在运行时期再确定一个实现此接口的对象

**动态分派**
当JVM遇到invokevirtual或invokeinterface时，需要运行时根据方法的符号引用查找到方法地址。具体过程如下：

1. 在方法调用指令之前，需要将对象的引用压入操作数栈
2. 在执行方法调用时，找到操作数栈顶的第一个元素所指向的对象实际类型，记作C
3. 在类型C中找到与常量池中的描述符和方法名称都相符的方法，并校验访问权限。如果找到该方法并通过校验，则返回这个方法的引用；
4. 否则，按照继承关系往上查找方法并校验访问权限；
5. 如果始终没找到方法，则抛出java.lang.AbstractMethodError异常；

可以看到，JVM是通过继承关系从子类往上查找的对应的方法的，为了提高动态分派时方法查找的效率，JVM为每个类都维护一个虚函数表。

### 2、OOM情况

- java.lang.OutOfMemoryError: Java heap space ------>java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。
- java.lang.OutOfMemoryError: PermGen space ------>java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。
- java.lang.StackOverflowError ------> 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。 但是如果程序在**不断的创建线程，这可能会产生OutOfMemoryError异常**，但是此种情况与栈空间是否足够大并没有任何关系

## 二、对象引用

### 1、四种引用方式

[参考](https://blog.csdn.net/u014532217/article/details/79184412)

## G1回收器

G1收集器兼顾低延迟和高吞吐在服务端运行。有两种收集模式Young GC和Mixed GC。G1收集器将堆内存划分成大小相等Region,新生代,老年代也就成了逻辑概念。整体上采用的是标记-整理算法,局部采用`复制算法。新生代,老年代的Region不再是一块连续的空间。当然存放大对象的Region必须要连续。

### G1与CMS区别

- G1采用`标记-整理`算法,CMS采用`标记-清除`算法,所以G1不会产生很多垃圾碎片.
- G1的STW(stop the world)可控,可以使用`-XX:MaxGCPauseMillis`设置默认200ms
- G1的`Young GC`模式可以工作在`年轻代`,而单独的`CMS`只能工作在`老年代`.

### G1应用场景

- 服务端多核CPU,JVM占用较大的应用(至少大于4G)。
- 应用在运行过程中产生大量的碎片,需要经常压缩。
- 想要更可控,可预期的停顿时间;防止高并发下应用雪崩现象。

