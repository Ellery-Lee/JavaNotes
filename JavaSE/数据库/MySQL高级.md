# [MySQL高级](https://www.bilibili.com/video/BV1KW411u7vy)

## 一、MySQL逻辑架构

和其他存储引擎相比，MySQL可以在多种不同场景中应用并发挥良好作用，主要体现在存储引擎的架构上，**插件式的存储引擎架构将查询处理和系统任务及数据的存储提取相分离**。可以根据实际的业务需求选择合适的存储引擎。

![MySQL逻辑架构.jpg](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.jpg?raw=true)

- 连接层
- 服务层
- 引擎层
- 存储层

**存储引擎**

- 命令查看：show engines;

- MyISAM和InnoDB

  ![MyISAM和InnoDB.jpg](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/MyISAM%E5%92%8CInnoDB.jpg?raw=true)

## 二、索引优化

### 1、性能下降SQL慢

- 查询语句写的烂
- 索引失效
- 关联查询太多join
- 服务器调优及各个参数设置(缓冲、线程数)

### 2、常见通用的join查询

#### ①、SQL的执行顺序

- 手写

- 机读

  ![SQL执行顺序.jpg](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/SQL%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.jpg?raw=true)

#### ②、JOIN

![join图.png](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/join%E5%9B%BE.png?raw=true)

- Inner Join

  ```sql
  select
  	<select_list>
  from
  	<Table A> A
  inner join
  	<Table B> B
  on
  	A.key = B.key
  ```

- Left Join

  ```sql
  select 
  	<select_list>
  from
  	<Table A> A
  left join
  	<Table B> B
  on
  	A.key = B.key
  ```

- Right Join

  ```sql
  select
  	<select_list>
  from 
  	<Table A> A
  right Join
  	<Table B> B
  on
  	A.key = B.key
  ```

- Left Join 左独占

  ```sql
  select 
  	<select_list>
  from
  	<Table A> A
  left join
  	<Table B> B
  on 
  	A.key = B.key
  where 
  	B.key is null
  ```

- Right Join 右独占

  ```sql
  select 
  	<select_list>
  from
  	<Table A> A
  right join
  	<Table B> B
  on 
  	A.key = B.key
  where 
  	A.key is null
  ```

- Outer Join(MySQL不支持)

  ```sql
  select 
  	<select_list>
  from
  	<Table A> A
  full outer join
  	<Table B> B
  on
  	A.key = B.key
  ```

- Outer Join 双方独有(MySQL不支持)

  ```sql
  select 
  	<select_list>
  from
  	<Table A> A
  full outer join
  	<Table B> B
  on 
  	A.key = B.key
  where
  	A.key is null
  or 
  	B.key is null
  ```

### 3、索引

MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构（where和order by）。可以得到索引的本质：**索引是数据结构**。简单的理解为：**排好序的快速查找数据结构**

一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上

**我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)结构组织的索引。**其中聚集索引，次要索引，覆盖索引，
复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈稀索引(hash index)等。

发展过程：

优势：

- 类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本
- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗

劣势：

- 实际上索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以索引列也是要占空间的
- 虽然索引大大提高了查询速度，但同时降低了更新表的速度，对表进行增删改时，MySQL不仅要保存数据，还要保存索引文件每次更新添加了索引列的字段
- 索引只是提高效率的一个因素，如果MySQL有大量的表，就需要花时间研究建立最优秀的索引，或优化查询

### 4、索引分类

- 主键索引：数据表的主键列使用的就是主键索引，主键索引机制(补充说明)

- 二级索引：

  - 普通索引：即一个索引只包含单个列，一个表可以有多个单列索引

  - 唯一索引：索引列的值必须唯一，但允许有空值

  - 复合索引：即一个索引包含多个列
  
    ![复合索引数据结构.png](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png?raw=true)
  
    对于联合索引来说只不过比单值索引多了几列，而这些索引列全都出现在索引树上。对于联合索引，存储引擎会首先根据第一个索引列排序，如上图我们可以单看第一个索引列，横着看，如，`1 1 5 12 13`....他是单调递增的；如果第一列相等则再根据第二列排序，依次类推就构成了上图的索引树，上图中的b列都等于1时，则根据c排序，此时c列也相等则按d列排序，如：`1 1 4` ，`1 1 5`，c=4在c=5前面，以及`13 12 4`,`13 16 1`,`13 16 5`就可以说明这种情况。
  
    复合索引查找方式：当我们的SQL语言可以应用到索引的时候，比如`select * from T1 where b = 12 and c = 14 and d = 3;` 也就是T1表中a列为4的这条记录。存储引擎首先从根节点（一般常驻内存）开始查找，第一个索引的第一个索引列为1,12大于1，第二个索引的第一个索引列为56,12小于56，于是从这俩索引的中间读到下一个节点的磁盘文件地址，从磁盘上Load这个节点，通常伴随一次磁盘IO，然后在内存里去查找。当Load叶子节点的第二个节点时又是一次磁盘IO，比较第一个元素，b=12,c=14,d=3完全符合，于是找到该索引下的data元素即ID值，再从主键索引树上找到最终数据。
  
    **最左前缀匹配原则**：首先我们创建的`index_bcd(b,c,d)`索引，相当于创建了(b)、（b、c）（b、c、d）三个索引，看完下面你就知道为什么相当于创建了三个索引。索引的第一列也就是b列可以说是从左到右单调递增的，但我们看c列和d列并没有这个特性，它们只能在b列值相等的情况下这个小范围内递增，如第一叶子节点的第1、2个元素和第二个叶子节点的后三个元素。  由于联合索引是上述那样的索引构建方式及存储结构，所以联合索引只能从多列索引的第一列开始查找。所以如果你的查找条件不包含b列如（c,d）、(c）、(d)是无法应用索引的，以及跨列也是无法完全用到索引如(b,d)，只会用到b列索引。[来源](https://juejin.cn/post/6844904073955639304)

**二级索引**：唯一索引，普通索引，前缀索引等索引属于二级索引。二级索引又称为辅助索引。

InnoDB和MyISAM的二级索引：

- InnoDB中二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。
- MyISAM中无论是主键索引还是二级索引，索引的叶子节点存放的都是指向数据行的指针，保证可以通过索引进而查找到对应的数据行，只需要对索引进行一遍查找。

### 5、聚集索引和非聚集索引

**聚集索引**即索引结构和数据一起存放的索引。**有且仅有InnoDB的主键索引属于聚集索引**。

优点：聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。

缺点：

- 依赖于有序的数据：因为B+树本身就是多路平衡树，如果索引不是有序的，就需要再插入时排序，如果是整型还好，如果是字符串或者UUID这种又长又难比较的数据，插入或查找的速度肯定比较慢。
- 更新代价大：如果索引列的数据被修改，那么对应的索引也将会被修改。并且聚集索引的叶子节点还存放数据，修改的代价较大。一般主键都不可修改。



**非聚集索引**即索引结构和数据分开存放的索引。

二级索引属于非聚集索引

非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。

优点：**更新代价比聚集索引要小** 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的

缺点：

- 跟聚集索引一样，非聚集索引也依赖于有序的数据
- **可能会二次查询(回表)** :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。

**非聚集索引一定回表查询吗(覆盖索引)?**

非聚集索引不一定回表查询。

- 如果用户准备使用SQL查询用户名，而用户名字段正好建立了索引，那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。

### 6、覆盖索引

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。因为如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢。覆盖索引就是**查询列被所建的索引覆盖**，不做回表操作！

### 7、基本语法

创建：

- CREATE [UNIQUE ]  INDEX [indexName] ON mytable  (columnname(length)) 

- ALTER mytable ADD  [UNIQUE ]  INDEX [indexName] ON (columnname(length)) 

删除：DROP INDEX [indexName] ON mytable; 

查看：SHOW INDEX FROM table_name

### 8、BTree索引（MyISAM普通索引）

![image-20210721161429911.png](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/image-20210721161429911.png?raw=true)

**初始化介绍**
一颗b树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示)，如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。

**查找过程**
如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。

真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

### 9、哪些情况适合建索引

- 主键自动建立唯一索引
- 频繁作为参训条件的字段应该创建索引
- 查询中与其他表关联的字段，外键关系建立索引
- 单键/组合索引的选择问题，who？(在高并发下倾向创建组合索引)
- 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
- 查询中统计或者分组字段

### 10、哪些情况不创建索引

- 表记录太少

- 经常增删改的表

  原因：提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件

- Where条件里用不到的字段不创建索引

- 数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。

## 三、性能分析

### 1、MySQL Query  Optimizer

MySQL中有专门负责优化select语句的优化器模块，主要功能：计算分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划(他认为最优的数据检索方式，不一定是DBA认为最优的，这部分最耗时间)

当客户端向MySQL请求一条Query，命令解析器模块完成请求分类，区别出是select并转发给MySQL Query Optimizer时，MySQL Query Optimizer首先会对整条Query进行优化，处理掉一些常量表达式的预算，直接转换成常量值。并对Query中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析Query中的Hint信息，看显示Hint信息是否可以完全确定该Query的执行计划。如果没有Hint或Hint信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据Query进行写相应的计算分析，然后再得出最后的执行计划。

### 2、MySQL常见瓶颈

- CPU：SQL中对大量数据进行比较、关联、排序、分组
- IO：
  - 实例内存满足不了缓存数据或排序等需要，导致产生大量 物理 IO。
  - 查询执行效率低，扫描过多数据行。
- 锁：
  - 不适宜的锁的设置，导致线程阻塞，性能下降。
  - 死锁，线程之间交叉调用资源，导致死锁，程序卡住。
- 服务器硬件的性能瓶颈：top,free, iostat和vmstat来查看系统的性能状态

## 四、Explain

使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈

**Explain + SQL语句**

执行计划包含信息：

![执行计划包含信息](D:\JavaHub\学习相关\Java笔记\pictures\执行计划包含信息.jpg)

### 1、各字段解释

- id：select查询的序列号,包含一组数字，**表示查询中执行select子句或操作表的顺序**

  - id相同：执行顺序由上至下
  - id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
  - id相同不同：同时存在

- select_type：查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询

  ![select_type.png](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/select_type.png?raw=true)

- table：显示这一行的数据是关于哪张表的

- type：

  ![explain_type.jpg](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/explain_type.jpg?raw=true)

  type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是： 

  system>const>eq_ref>ref>range>index>ALL

  一般来说，得保证查询至少达到range级别，最好能达到ref。

  - system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计
  - const：表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。比如**将一个主键放置到where后面作为条件查询**，mysql优化器就能把这次查询优化转化为一个常量。
  - eq_ref：**用于联表查询**。唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。
  - ref：非唯一性索引扫描，返回匹配某个单独值的所有行。查找条件列使用了索引而且不为主键和unique。其实，意思就是虽然使用了索引，但该索引列的值并不唯一，有重复。
  - range：**一定是基于索引的**。只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引。一般就是在你的where语句中出现了between、<、>、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。
  - index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快。(实际上index扫描要回表扫描，不可能比all快，唯一原因就是index按序扫描且索引文件通常比数据文件小)（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）
  - all：Full Table Scan，将遍历全表以找到匹配的行。

- possible_keys

  显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用

- key

  实际使用的索引。如果为NULL，则没有使用索引。查询中若使用了覆盖索引，则该索引和查询的select字段重叠

- key_len

  表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。**key_len显示的值为索引字段的最大可能长度，并非实际长度**，即key_len是根据表定义计算而得，不是通过表内检索出的。key_len字段能够帮你检查是否充分的利用上了索引

- ref

  显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量   被用于查找索引列上的值

  ![explain_ref.png](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/explain_ref.png?raw=true)

- rows

  rows列显示MySQL认为它执行查询时必须读取的行数。

- extra

  包含不适合在其他列中显示但十分重要的额外信息。

  - **Using filesort**：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”

  - **Using temporary**：使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。

  - **Using index**：**表示相应的select操作中使用了覆盖索引(Covering Index)**，避免访问了表的数据行，效率不错！如果同时出现using where，表明索引被用来执行索引键值的查找;如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。

    覆盖索引(Covering Index)

  - Using where：表明使用了where过滤

  - Using join buffer：使用了连接缓存

  - Impossible where：where子句的值总是false，不能用来获取任何元组

  - select tables optimized away：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。

## 五、索引优化案例分析

- 双表左连接建右表，右连接建左表
- 保证被驱动表的join字段已经被索引 (被驱动表  join 后的表为被驱动表  (需要被查询))
- left join 时，选择小表作为驱动表，大表作为被驱动表。(但是 left join 时一定是左边是驱动表，右边是被驱动表)
- inner join 时，mysql会自己帮你把小结果集的表选为驱动表。(mysql 自动选择。小表作为驱动表。因为 驱动表无论如何都会被全表扫描。所以扫描次数越少越好)
- 子查询尽量不要放在被驱动表，有可能使用不到索引。

## 六、索引失效的原因

- 全值匹配我最爱
- 最佳左前缀法则
- 不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描
- 存储引擎不能使用索引中范围条件右边的列
- 尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select *
- mysql 在使用不等于(!= 或者<>)的时候无法使用索引会导致全表扫描
- is not null 无法使用索引,但是is null 可以使用索引
- like以通配符开头('%abc...')mysql索引失效会变成全表扫描的操作，如果%加在右边则索引不会失效(abc...%)
  - 如果一定要使用两边百分号like，使用覆盖索引解决索引失效问题
- 字符串不加单引号索引失效，mysql底层进行了类型转换，导致索引失效
- 少用or,用它来连接时会索引失效

**一般性建议：**

- 对于单键索引，尽量选择针对当前query过滤性更好的索引
- 在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。(避免索引过滤性好的索引失效)
- 在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引
- 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的

## 补充：

#### 1、MySQL为什么要用自增id作为主键

- 存储原理：数据本身被存于索引的叶子节点上，这就要求同一个叶子节点内(大小为一个内存页或磁盘页)的各条数据记录按主键顺序存放，当每一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到了装载因子(InnoDB默认为15/16)，则开辟一个新的页。
- 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页(节点)，这样和B+数叶子节点的分裂顺序一致。
- 如果表使用非自增主键，每次插入的值随机，因此每次插入的记录都是当前索引页的某个中间位置，此时MySQL就需要为了插入新数据而移动旧数据，如果遇到当前索引页写满的情况，就需要把数据移动到其他索引页，这会增加很多开销。
- 索引字段选取规则：如果定义了主键，那么InnoDB会选择主键作为聚集索引，如果没有显式定义主键，则InnoDB会选择第一个不包含Null值的唯一索引作为主键索引，如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引。

