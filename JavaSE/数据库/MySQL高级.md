# [MySQL高级](https://www.bilibili.com/video/BV1KW411u7vy)

## 一、MySQL逻辑架构

和其他存储引擎相比，MySQL可以在多种不同场景中应用并发挥良好作用，主要体现在存储引擎的架构上，**插件式的存储引擎架构将查询处理和系统任务及数据的存储提取相分离**。可以根据实际的业务需求选择合适的存储引擎。

![MySQL逻辑架构.jpg](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.jpg?raw=true)

- 连接层
- 服务层
- 引擎层
- 存储层

**存储引擎**

- 命令查看：show engines;

- MyISAM和InnoDB

  ![MyISAM和InnoDB.jpg](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/MyISAM%E5%92%8CInnoDB.jpg?raw=true)

## 二、索引优化

### 1、性能下降SQL慢

- 查询语句写的烂
- 索引失效
- 关联查询太多join
- redo log日志写满了正在同步到磁盘
- 执行的时候遇到锁

### 2、常见通用的join查询

#### ①、SQL的执行顺序

- 手写

- 机读

  ![SQL执行顺序.jpg](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/SQL%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.jpg?raw=true)

#### ②、JOIN

![join图.png](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/join%E5%9B%BE.png?raw=true)

- Inner Join

  ```sql
  select
  	<select_list>
  from
  	<Table A> A
  inner join
  	<Table B> B
  on
  	A.key = B.key
  ```

- Left Join

  ```sql
  select 
  	<select_list>
  from
  	<Table A> A
  left join
  	<Table B> B
  on
  	A.key = B.key
  ```

- Right Join

  ```sql
  select
  	<select_list>
  from 
  	<Table A> A
  right Join
  	<Table B> B
  on
  	A.key = B.key
  ```

- Left Join 左独占

  ```sql
  select 
  	<select_list>
  from
  	<Table A> A
  left join
  	<Table B> B
  on 
  	A.key = B.key
  where 
  	B.key is null
  ```

- Right Join 右独占

  ```sql
  select 
  	<select_list>
  from
  	<Table A> A
  right join
  	<Table B> B
  on 
  	A.key = B.key
  where 
  	A.key is null
  ```

- Outer Join(MySQL不支持)

  ```sql
  select 
  	<select_list>
  from
  	<Table A> A
  full outer join
  	<Table B> B
  on
  	A.key = B.key
  ```

- Outer Join 双方独有(MySQL不支持)

  ```sql
  select 
  	<select_list>
  from
  	<Table A> A
  full outer join
  	<Table B> B
  on 
  	A.key = B.key
  where
  	A.key is null
  or 
  	B.key is null
  ```

### 3、索引

MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构（where和order by）。可以得到索引的本质：**索引是数据结构**。简单的理解为：**排好序的快速查找数据结构**

一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上

**我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)结构组织的索引。**其中聚集索引，次要索引，覆盖索引，
复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈稀索引(hash index)等。

发展过程：

优势：

- 类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本
- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗

劣势：

- 实际上索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以索引列也是要占空间的
- 虽然索引大大提高了查询速度，但同时降低了更新表的速度，对表进行增删改时，MySQL不仅要保存数据，还要保存索引文件每次更新添加了索引列的字段
- 索引只是提高效率的一个因素，如果MySQL有大量的表，就需要花时间研究建立最优秀的索引，或优化查询

### 4、索引分类

- 主键索引：数据表的主键列使用的就是主键索引，主键索引机制(补充说明)

- 二级索引：

  - 普通索引：即一个索引只包含单个列，一个表可以有多个单列索引

  - 唯一索引：索引列的值必须唯一，但允许有空值

  - 复合索引：即一个索引包含多个列
  
    ![复合索引数据结构.png](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png?raw=true)
  
    对于联合索引来说只不过比单值索引多了几列，而这些索引列全都出现在索引树上。对于联合索引，存储引擎会首先根据第一个索引列排序，如上图我们可以单看第一个索引列，横着看，如，`1 1 5 12 13`....他是单调递增的；如果第一列相等则再根据第二列排序，依次类推就构成了上图的索引树，上图中的b列都等于1时，则根据c排序，此时c列也相等则按d列排序，如：`1 1 4` ，`1 1 5`，c=4在c=5前面，以及`13 12 4`,`13 16 1`,`13 16 5`就可以说明这种情况。
  
    复合索引查找方式：当我们的SQL语言可以应用到索引的时候，比如`select * from T1 where b = 12 and c = 14 and d = 3;` 也就是T1表中a列为4的这条记录。存储引擎首先从根节点（一般常驻内存）开始查找，第一个索引的第一个索引列为1,12大于1，第二个索引的第一个索引列为56,12小于56，于是从这俩索引的中间读到下一个节点的磁盘文件地址，从磁盘上Load这个节点，通常伴随一次磁盘IO，然后在内存里去查找。当Load叶子节点的第二个节点时又是一次磁盘IO，比较第一个元素，b=12,c=14,d=3完全符合，于是找到该索引下的data元素即ID值，再从主键索引树上找到最终数据。
  
    **最左前缀匹配原则**：首先我们创建的`index_bcd(b,c,d)`索引，相当于创建了(b)、（b、c）（b、c、d）三个索引，看完下面你就知道为什么相当于创建了三个索引。索引的第一列也就是b列可以说是从左到右单调递增的，但我们看c列和d列并没有这个特性，它们只能在b列值相等的情况下这个小范围内递增，如第一叶子节点的第1、2个元素和第二个叶子节点的后三个元素。  由于联合索引是上述那样的索引构建方式及存储结构，所以联合索引只能从多列索引的第一列开始查找。所以如果你的查找条件不包含b列如（c,d）、(c）、(d)是无法应用索引的，以及跨列也是无法完全用到索引如(b,d)，只会用到b列索引。[来源](https://juejin.cn/post/6844904073955639304)

**二级索引**：唯一索引，普通索引，前缀索引等索引属于二级索引。二级索引又称为辅助索引。

InnoDB和MyISAM的二级索引：

- InnoDB中二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。
- MyISAM中无论是主键索引还是二级索引，索引的叶子节点存放的都是指向数据行的指针，保证可以通过索引进而查找到对应的数据行，只需要对索引进行一遍查找。

### 5、聚集索引和非聚集索引

**聚集索引**即索引结构和数据一起存放的索引。**有且仅有InnoDB的主键索引属于聚集索引**。

优点：聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。

缺点：

- 依赖于有序的数据：因为B+树本身就是多路平衡树，如果索引不是有序的，就需要再插入时排序，如果是整型还好，如果是字符串或者UUID这种又长又难比较的数据，插入或查找的速度肯定比较慢。
- 更新代价大：如果索引列的数据被修改，那么对应的索引也将会被修改。并且聚集索引的叶子节点还存放数据，修改的代价较大。一般主键都不可修改。
- **可能会二次查询(回表)** :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。

**聚集索引一定回表查询吗(覆盖索引)?**

聚集索引不一定回表查询。

- 如果用户准备使用SQL查询用户名，而用户名字段正好建立了索引，那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。



**非聚集索引**即索引结构和数据分开存放的索引。

二级索引属于非聚集索引

非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。

优点：**更新代价比聚集索引要小** 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的

缺点：

- 跟聚集索引一样，非聚集索引也依赖于有序的数据



### 6、覆盖索引

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。因为如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢。覆盖索引就是**查询列被所建的索引覆盖**，不做回表操作！

### 7、基本语法

创建：

- CREATE [UNIQUE ]  INDEX [indexName] ON mytable  (columnname(length)) 

- ALTER mytable ADD  [UNIQUE ]  INDEX [indexName] ON (columnname(length)) 

删除：DROP INDEX [indexName] ON mytable; 

查看：SHOW INDEX FROM table_name

### 8、B+Tree索引（MyISAM普通索引）

![image-20210721161429911.png](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/image-20210721161429911.png?raw=true)

**初始化介绍**
一颗b树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示)，如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。

**查找过程**
如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。

真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

### 9、哪些情况适合建索引

- 主键自动建立唯一索引
- 频繁作为参训条件的字段应该创建索引
- 查询中与其他表关联的字段，外键关系建立索引
- 单键/组合索引的选择问题，who？(在高并发下倾向创建组合索引)
- 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
- 查询中统计或者分组字段

### 10、哪些情况不创建索引

- 表记录太少

- 经常增删改的表

  原因：提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件

- Where条件里用不到的字段不创建索引

- 数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。

## 三、索引失效的原因

- 全值匹配我最爱
- 最佳左前缀法则
- 不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描
- 存储引擎不能使用索引中范围条件右边的列
- 尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select *
- mysql 在使用不等于(!= 或者<>)的时候无法使用索引会导致全表扫描
- is not null 无法使用索引,但是is null 可以使用索引
- like以通配符开头('%abc...')mysql索引失效会变成全表扫描的操作，如果%加在右边则索引不会失效(abc...%)
  - 如果一定要使用两边百分号like，使用覆盖索引解决索引失效问题
- 字符串不加单引号索引失效，mysql底层进行了类型转换，导致索引失效
- 少用or,用它来连接时会索引失效

**一般性建议：**

- 对于单键索引，尽量选择针对当前query过滤性更好的索引
- 在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。(避免索引过滤性好的索引失效)
- 在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引
- 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的

## 四、性能分析

### 1、MySQL Query  Optimizer

MySQL中有专门负责优化select语句的优化器模块，主要功能：计算分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划(他认为最优的数据检索方式，不一定是DBA认为最优的，这部分最耗时间)

当客户端向MySQL请求一条Query，命令解析器模块完成请求分类，区别出是select并转发给MySQL Query Optimizer时，MySQL Query Optimizer首先会对整条Query进行优化，处理掉一些常量表达式的预算，直接转换成常量值。并对Query中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析Query中的Hint信息，看显示Hint信息是否可以完全确定该Query的执行计划。如果没有Hint或Hint信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据Query进行写相应的计算分析，然后再得出最后的执行计划。

### 2、MySQL常见瓶颈

- CPU：SQL中对大量数据进行比较、关联、排序、分组
- IO：
  - 实例内存满足不了缓存数据或排序等需要，导致产生大量 物理 IO。
  - 查询执行效率低，扫描过多数据行。
- 锁：
  - 不适宜的锁的设置，导致线程阻塞，性能下降。
  - 死锁，线程之间交叉调用资源，导致死锁，程序卡住。
- 服务器硬件的性能瓶颈：top,free, iostat和vmstat来查看系统的性能状态

## 五、Explain

使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈

**Explain + SQL语句**

执行计划包含信息：

![执行计划包含信息](D:\JavaHub\学习相关\Java笔记\pictures\执行计划包含信息.jpg)

### 1、各字段解释

- id：select查询的序列号,包含一组数字，**表示查询中执行select子句或操作表的顺序**

  - id相同：执行顺序由上至下
  - id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
  - id相同不同：同时存在

- select_type：查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询

  ![select_type.png](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/select_type.png?raw=true)

- table：显示这一行的数据是关于哪张表的

- type：

  ![explain_type.jpg](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/explain_type.jpg?raw=true)

  type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是： 

  system>const>eq_ref>ref>range>index>ALL

  一般来说，得保证查询至少达到range级别，最好能达到ref。

  - system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计
  - const：表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。比如**将一个主键放置到where后面作为条件查询**，mysql优化器就能把这次查询优化转化为一个常量。
  - eq_ref：**用于联表查询**。唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。
  - ref：非唯一性索引扫描，返回**匹配某个单独值**(where name = '张三')的所有行。查找条件列使用了索引而且不为主键和unique。其实，意思就是虽然使用了索引，但该索引列的值并不唯一，有重复。
  - range：**一定是基于索引的**。只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引。一般就是在你的where语句中出现了between、<、>、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。
  - index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快。(实际上index扫描要回表扫描，不可能比all快，唯一原因就是index按序扫描且索引文件通常比数据文件小)（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）
  - all：Full Table Scan，将遍历全表以找到匹配的行。

- possible_keys

  显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用

- key

  实际使用的索引。如果为NULL，则没有使用索引。查询中若使用了覆盖索引，则该索引和查询的select字段重叠

- key_len

  表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。**key_len显示的值为索引字段的最大可能长度，并非实际长度**，即key_len是根据表定义计算而得，不是通过表内检索出的。key_len字段能够帮你检查是否充分的利用上了索引

- ref

  显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量   被用于查找索引列上的值

  ![explain_ref.png](https://github.com/Ellery-Lee/JavaNotes/blob/master/pictures/explain_ref.png?raw=true)

- rows

  rows列显示MySQL认为它执行查询时必须读取的行数。

- extra

  包含不适合在其他列中显示但十分重要的额外信息。

  - **Using filesort**：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”

  - **Using temporary**：使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。

  - **Using index**：**表示相应的select操作中使用了覆盖索引(Covering Index)**，避免访问了表的数据行，效率不错！如果同时出现using where，表明索引被用来执行索引键值的查找;如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。

    覆盖索引(Covering Index)

  - Using where：表明使用了where过滤

  - Using join buffer：使用了连接缓存

  - Impossible where：where子句的值总是false，不能用来获取任何元组

  - select tables optimized away：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。

## 六、查询优化

### 1、索引优化

- 双表左连接建右表，右连接建左表
- 保证被驱动表的join字段已经被索引 (被驱动表  join 后的表为被驱动表  (需要被查询))
- left join 时，选择小表作为驱动表，大表作为被驱动表。(但是 left join 时一定是左边是驱动表，右边是被驱动表)
- inner join 时，mysql会自己帮你把小结果集的表选为驱动表。(mysql 自动选择。小表作为驱动表。因为 驱动表无论如何都会被全表扫描。所以扫描次数越少越好)
- 子查询尽量不要放在被驱动表，有可能使用不到索引。

### 2、子查询优化

**用in还是exist**



### 3、Order by关键字优化

**MySQL支持二种方式的排序，FileSort和Index，Index效率高。它指MySQL扫描索引本身完成排序。FileSort方式效率较低。**

ORDER BY满足两情况，会使用Index方式排序:

- ORDER BY 语句使用索引最左前列
- 使用Where子句与Order BY子句条件列组合满足索引最左前列

如果不在索引列上，filesort有两种算法：mysql就要启动双路排序和单路排序

- 双路排序
  - MySQL 4.1之前是使用双路排序,字面意思就是**两次扫描磁盘**，最终得到数据，读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出
  - 从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。
  - 取一批数据，要对磁盘进行了两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。
- 单路排序
  - 从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO,但是它会使用更多的空间，因为它把每一行都保存在内存中了。
  - 单路也有问题。在sort_buffer中，单路比双路要多占用很多空间，因为单路是把所有字段都取出, 所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取取sort_buffer容量大小，再排……从而多次I/O。本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。

优化策略：

- 增大sort_buffer_size参数的设置
- 增大max_length_for_sort_data参数的设置
- 去掉select 后面不需要的字段
- 提高Order By的速度
  - Order by时select * 是一个大忌只Query需要的字段， 这点非常重要。在这里的影响是： 1.1 当Query的字段大小总和小于max_length_for_sort_data 而且排序字段不是 TEXT|BLOB 类型时，会用改进后的算法——单路排序， 否则用老算法——多路排序。 1.2 两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的风险会更大一些,所以要提高sort_buffer_size。
  -  尝试提高 sort_buffer_size不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的3. 尝试提高 max_length_for_sort_data提高这个参数， 会增加用改进算法的概率。但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率. 

### 4、Group by

- group by实质是先排序后进行分组，遵照索引建的最佳左前缀
- 当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置
- where高于having，能写在where限定的条件就不要去having限定了。
- 尽量不要使用 distinct 关键字去重：优化 

## 七、查询截取分析

- 慢查询的开启并捕获
- explain+慢SQL分析
- show profile查询SQL在MySQL服务器里面的执行细节和生命周期情况
- SQL数据库服务器的参数调优

## 八、慢查询日志

MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。 具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。 由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。 

默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件

**什么样的sql会被记录？**

这个是由参数long_query_time控制，默认情况下long_query_time的值为10秒，命令：SHOW VARIABLES LIKE 'long_query_time%';可以使用命令修改，也可以在my.cnf参数里面修改。假如运行时间正好等于long_query_time的情况，并不会被记录下来。也就是说，在mysql源码里是判断大于long_query_time，而非大于等于。 

**相关指令：**

- 查看当前多少秒算慢：SHOW VARIABLES LIKE 'long_query_time%';
- 设置慢的阈值时间：set global long_query_time=1修改为阙值到1秒钟的就是慢sql 修改后发现long_query_time并没有改变。 需要重新连接或者重新开启会话
- 查询当前系统中有多少条慢查询记录： show global status like '%Slow_queries%';  

## 九、锁机制

### 1、锁的分类

从对数据操作的类型（读\写）分：

- 读锁(共享锁)：针对同一份数据，多个读操作可以同时进行而不会互相影响。
- 写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。

从对数据操作的粒度分：

- 表锁（偏读）
- 行锁（偏写）
- 页锁

### 2、表锁

偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。

查看锁：show open tables

加读锁：lock table 表名 read

加写锁：lock table 表名 write

MyISAM在执行查询语句（SELECT）前，会**自动给涉及的所有表加读锁**，在执行增删改操作前，会**自动给涉及的表加写锁**。 MySQL的表级锁有两种模式： 表共享读锁（Table Read Lock） 表独占写锁（Table Write Lock 结论： 结合上表，所以对MyISAM表进行操作，会有以下情况：  

- 对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。 
-  对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。 简而言之，就是读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞

总结：**读锁会阻塞写，写锁会阻塞读和写。**此外，MyISAM的锁调度是写优先，这也是MyISAM不适合作为写为主的表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁从而造成永远阻塞。

### 3、行锁

偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。

InnoDB与MyISAM的最大不同有两点：**一是支持事务（TRANSACTION）；二是采用了行级锁**

**无索引行升级为表锁：**

Session_1Session_2正常情况，各自锁定各自的行，互相不影响，一个2000另一个3000。由于在column字段b上面建了索引，如果没有正常使用，会导致行锁变表锁。**比如没加单引号导致索引失效，行锁变表锁被阻塞，等待。**只到Session_1提交后才阻塞解除，完成更新 

**间隙锁：**

间隙锁带来的插入问题 Session_1Session_2阻塞产生，暂时不能插入commit;阻塞解除，完成插入 

【什么是间隙锁】当我们用**范围条件而不是相等条件**检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于**键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”**，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（GAP Lock）。 

【危害】因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害

**如何锁定一行？**

**排他锁**（eXclusive Lock）排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。用法SELECT ... FOR UPDATE;    在查询语句后面增加 FOR UPDATE ，**Mysql会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。** 

**共享锁**(Share Lock) 共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。 用法SELECT ... LOCK IN SHARE MODE; 在查询语句后面增加 LOCK IN SHARE MODE ，**Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表（行？），而且这些线程读取的是同一个版本的数据。** 

**结论：** Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。 但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。

**行锁分析：**通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况mysql>show status like 'innodb_row_lock%'; 对各个状态量的说明如下： 

- Innodb_row_lock_current_waits：当前正在等待锁定的数量；

- Innodb_row_lock_time：从系统启动到现在锁定总时间长度；

- Innodb_row_lock_time_avg：每次等待所花平均时间；

- Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；

- Innodb_row_lock_waits：系统启动后到现在总共等待的次数；

  对于这5个状态变量，比较重要的主要是 Innodb_row_lock_time_avg（等待平均时长）， Innodb_row_lock_waits（等待总次数） Innodb_row_lock_time（等待总时长）这三项。尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。最后可以通过SELECT * FROM information_schema.INNODB_TRX\G;来查询正在被锁阻塞的sql语句。

**优化建议：**

- 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。
- 尽可能较少检索条件，避免间隙锁
- 尽量控制事务大小，减少锁定资源量和时间长度
- 锁住某行后，尽量不要去调别的行或表，赶紧处理被锁住的行然后释放掉锁。
- 涉及相同表的事务，对于调用表的顺序尽量保持一致。
- 在业务环境允许的情况下,尽可能低级别事务隔离

## 十、redo log和bin log

- redo log是属于innoDB引擎层面，binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。
- redo log是物理日志，记录该数据页更新的内容；binlog是逻辑日志，记录的是这个更新语句的原始逻辑，增删改SQL语句
- redo log是循环写，日志空间大小固定；binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。
- binlog可以作为**恢复数据使用，主从复制搭建**，redo log作为**异常宕机或者介质故障后的数据恢复使用**。

## 十、主从复制

未完待续。。。

## 十一、数据库和缓存一致性解决方案

- **采用延时双删策略**：

  1. 先删除缓存
  2. 再写数据库
  3. 休眠500毫秒
  4. 再次删除缓存

  这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。

- **异步更新缓存(基于订阅binlog的同步机制)**

  - **读Redis**：热数据基本都在Redis
  - **写MySQL**:增删改都是操作MySQL
  - **更新Redis数据**：MySQ的数据操作binlog，来更新到Redis

  这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。

## 补充：

#### 1、MySQL为什么要用自增id作为主键

- 存储原理：数据本身被存于索引的叶子节点上，这就要求同一个叶子节点内(大小为一个内存页或磁盘页)的各条数据记录按主键顺序存放，当每一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到了装载因子(InnoDB默认为15/16)，则开辟一个新的页。
- 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页(节点)，这样和B+数叶子节点的分裂顺序一致。
- 如果表使用非自增主键，每次插入的值随机，因此每次插入的记录都是当前索引页的某个中间位置，此时MySQL就需要为了插入新数据而移动旧数据，如果遇到当前索引页写满的情况，就需要把数据移动到其他索引页，这会增加很多开销。
- 索引字段选取规则：如果定义了主键，那么InnoDB会选择主键作为聚集索引，如果没有显式定义主键，则InnoDB会选择第一个不包含Null值的唯一索引作为主键索引，如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引。

#### 2、in和exists区别

- 使用exists关键字进行查询的时候，首先，我们先查询的不是子查询的内容，而是查我们的主查询的表。
- in在查询的时候，首先查询子查询的表，然后将内表和外表做一个笛卡尔积，然后按照条件进行筛选。所以相对内表比较小的时候，in的速度较快。

#### 3、乐观锁和悲观锁

悲观锁（Pessimistic Lock）： 
每次获取数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁。由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待。（Synchronized和MySQL排他锁）

适用场景：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。

乐观锁（Optimistic Lock）： 
每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。

适用场景：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。（CAS机制和版本号机制）

#### 4、B+数索引和Hash索引

- Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。 
  由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。 
- Hash 索引无法被用来避免数据的排序操作。 
  由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算； 
- Hash 索引不能利用部分索引键查询。 
  对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。 
- Hash 索引在任何时候都不能避免表扫描。 
  前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。 
- Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。 
  对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。
