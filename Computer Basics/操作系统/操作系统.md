# 操作系统

## 一、进程通信

### 1、管道

管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或满的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。

**匿名管道：**

- 管道是**半双工的**，数据只能向一个方向流动；**需要双方通信时，需要建立起两个管道**
- **匿名管道只能用于父子进程或者兄弟进程之间**（具有亲缘关系的进程）
- 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。

**有名管道**

- 和无名管道的主要区别在于，命名管道有一个名字，命名管道的名字对应于一个磁盘索引节点，有了这个文件名，**任何进程有相应的权限都可以对它进行访问**。

### 2、消息队列

- **消息队列是一个消息的链表**，保存在内核中。消息队列中的每个消息都是一个**数据块**，**具有特定的格式**。操作系统中可以存在多个消息队列，每个消息队列有唯一的 **key**，称为消息队列标识符。
- 消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。

### 3、共享内存

- 共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。

- **共享内存的优点是简单且高效**，访问共享内存区域和访问进程独有的内存区域一样**快**，原因是**不需要系统调用，不涉及用户态到内核态的转换，也不需要对数据不必要的复制**。比如管道和消息队列，需要在内核和用户空间进行四次的数据拷贝（读输入文件、写到管道；读管道、写到输出文件），而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。
- **共享内存的缺点是存在并发问题**，有可能出现多个进程修改同一块内存，因此共享内存一般与信号量结合使用。

### 4、信号量

- 信号量是一种特殊的变量，对它的操作都是原子的，有两种操作：V（`signal()`）和 P（`wait()`）。V 操作会增加信号量 S 的数值，P 操作会减少它。**用于多进程对共享数据的访问，信号量的意图在于进程间同步**
- 如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的 0 或 1，称为二进制信号量（binary semaphore）。在 Linux 系统中，二进制信号量又称互斥锁（Mutex）。信号量可以用于实现进程或线程的互斥和同步。

### 5、信号

- 信号是 Linux 系统响应某些条件而产生的一个事件，由操作系统事先定义，接收到该信号的进程可以采取自定义的行为。
- 一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是进程间通信机制中**唯一的异步通信机制**，一个进程不必通过任何操作来等待信号的到达

### 6、套接字socket

- 不同的计算机的进程之间通过 socket 通信，**也可用于同一台计算机的不同进程**
- 需要通信的进程之间首先要各自创建一个 socket，**内容包括主机地址与端口号**，声明自己接收来自某端口地址的数据
- 进程通过 socket 把消息发送到网络层中，网络层通过主机地址将其发到目的主机，目的主机通过端口号发给对应进程

## 二、陷入和中断

### 1、系统调用、异常和中断

用户程序通过系统调用请求系统服务

**异常：**指产生中断的CPU无法完成的一些指令，例如除以0。当异常发生时，CPU将**当前指令的地址（而不是下一条指令的地址）压入栈**，作为异常服务的返回地址。这样，就可以在异常处理返回时完成未竟完成的事业。

**中断：**指硬件产生的希望引起操作系统注意的信号，对CPU来说是被动的，例如硬盘读完一个数据块，会产生中断提醒操作系统准备好被获取了。所有的中断都**由内核管理**，而不是进程。因为在大多数情况下只有内核拥有处理中断所需的特权和状态。当中断发生时，**CPU将下一条指令**，也就是接下来要执行的指令的地址压入栈作为中断服务的返回地址。

**陷入：**是由CPU本身在执行程序过程中产生的。它是由专设的指令，如程序调试中的断点，在程序中有意产生的，是主动的。同中断一样，当陷入发生时，**CPU将下一条指令**，也就是接下来要执行的指令的地址压入栈，作为中断服务的返回地址。

