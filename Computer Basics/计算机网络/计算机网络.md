# 一、应用层

## 1、Http vs. Https

**Http：**超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，通常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议，所有的www文件都必须遵守这个标准。

**HTTP协议包括两部分：**

- 请求协议：从Browser发送到Server的时候采用的数据传送格式
- 响应协议：从Server发送到Browser的时候采用的数据传送格式

**HTTP请求协议报文结构：**请求行，请求头、空白行、请求体

- 请求行：请求方式 URL 协议版本号
- 空白行：专门用来分离消息报头和请求体的

![这里写图片描述](http://www.2cto.com/uploadfile/Collfiles/20160921/20160921092902554.png)

**HTTP相应协议报文结构：**状态行、响应报头、空白行、响应体

- 状态行：协议版本号 状态码 状态描述信息
- 空白行：分离响应报头和响应体的
- **相应协议中重点掌握状态码：**
  - 200响应成功，正常结束
  - 404资源未找到
  - 500服务器内部错误



**特点：**

- 无状态：协议对客户端没有状态存储，对事物没有记忆能力，比如访问一个网站需要反复进行登录操作。
- 无连接：每次和服务器要重新连接，重新响应请求。
- 通信明文传输，请求和响应不会对通信方进行确认，无法保护数据完整性。
- Http使用80端口

**HTTPS：**基于Http协议，通过SSL或TLS提供加密处理数据，验证对方身份以及数据完整性保护。

**特点：**

- Https使用443端口
- Https运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全
- Https通信需要证书，一般需要向证书颁发机构（CA）购买

## 2、HTTP的长连接和短连接

HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包。

**短连接：**在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

**长连接：**而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```HTML
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。**实现长连接需要客户端和服务端都支持长连接。**

### ①TCP的长连接和短连接

**短连接：**双方建立连接。client向server发送消息，server回应client，然后一次请求就完成了，关闭连接。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。上述可知，短连接一般只会在 client/server间传递一次请求操作。

**长连接：**双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

TCP的保活功能主要由服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。**如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段。**

### ②长连接短连接优缺点

长连接优点：**长连接**可以**省去较多的TCP建立和关闭的操作，减少浪费，节约时间**。对于频繁请求资源的客户来说，较适用长连接。

长连接缺点：在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，**Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候。**

短连接优点：**短连接**对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。

短连接缺点：如果客户**请求频繁**，将在**TCP的建立和关闭操作上浪费时间和带宽**。



## 3、Https连接(四次握手)过程 [参考](https://lkchan.com/https%E5%85%AC%E9%92%A5%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%EF%BC%8Cssl%E8%BF%9E%E6%8E%A5/)

1. 客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）
2. 服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，**加密公钥**（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）
3. 客户端验证服务器的合法性，包括：证书是否过期，CA 是否可靠，**客户端使用本地根证书解服务器的数字证书的签名，并且用同样的Hash算法生成摘要，对比数据摘要是否一致，一致则合法。**
4. 如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个**随机密钥**（用于对称算法，**根据本地+服务端随机数**），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行**摘要**计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器
5. 服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器
6. 浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加

**总结：**非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/5/16f7422942739bf8~tplv-t2oaga2asx-watermark.awebp)

### ①什么是对称加密、非对称加密？区别是什么？

- 对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4
- 非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA
- 区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥）



## 4、访问的网站是如何自动切换到HTTPS的？

一种是原始的302跳转，服务器把所有的HTTP流量跳转到HTTPS。但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。 解决方法是引入HSTS机制，用户浏览器在访问站点的时候强制使用HTTPS。



## 5、GET和POST有什么区别？

只有当使用表单form，并且将form标签的method属性设置为method=“post”，才是post请求方式，其余剩下所有的请求方式都是基于GET方式的。

### ①、区别

1. **GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源。GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的。**

   读取“一个资源。比如Get到一个html文件。反复读取不应该对访问的数据有副作用。比如”GET一下，用户就下单了，返回订单已受理“，这是不可接受的。没有副作用被称为“幂等“（Idempotent)。

   比如通过POST下一个单，服务器创建了新的订单，然后返回订单成功的界面。这个页面不能被缓存。试想一下，如果POST请求被浏览器缓存了，那么下单请求就可以不向服务器发请求，而直接返回本地缓存的“下单成功界面”，却又没有真的在服务器下单。那是一件多么滑稽的事情。

2. **安全性：因为POST用body传输数据，而GET用url传输。**

   GET请求因其数据明文出现在URL中可被缓存、收藏、保留到历史记录。POST的参数不会被保存，安全性相对较高。

   但是从攻击的角度，无论是GET还是POST都不够安全，因为HTTP本身是明文协议**。**每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body。这完全不是一个“是否容易在浏览器地址栏上看到“的问题。

3. **GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制。**

   不论是GET和POST都可以使用URL传递数据，所以我们常说的“GET数据有长度限制“其实是指”URL的长度限制“。HTTP协议本身对URL长度并没有做任何规定。实际的限制是由客户端/浏览器以及服务器端决定的。

4. **GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据。**

   GET的参数只能支持ASCII，而POST能支持任意binary，包括中文。但其实从上面可以看到，GET和POST实际上都能用url和body。因此所谓编码确切地说应该是http中url用什么编码，body用什么编码。

### ②、如何选择

- 有敏感数据，必须使用POST
- 传送数据不是普通字符串，必须使用POST
- 传送的数据非常多，使用POST
- 这个请求是为了修改服务器端资源，使用POST
- GET请求多数情况下是从服务器读取资源，这个读取的资源在短时间内是不会发生变化的，所以GET请求最终的结果浏览器缓存起来了。
- POST请求是为了修改服务器端的资源，而每一次修改结果都是不同的，最终结果没有必要被浏览器缓存。

- 浏览器将资源缓存后，缓存的资源是和某个特定的路径绑定在一起的，只要浏览器发送相同的请求路径，这个时候会去缓存中获取资源，不再访问服务器，以这种方式降低服务器的压力，提高用户的体验。但是有时候，我们不希望走缓存，希望每一次都访问服务器，可以在请求路径后面添加时间戳，例如http://ip:port/oa/logout?timestamp=321321

  JS获取毫秒：new Date().getTime();

### ③、前端后端请求方式统一

- 前端的页面发送的请求方式应当和服务器端需要的请求方式一致

  - 服务器需要前端发送POST请求，那前端就应该发送POST请求，若发送GET请求，服务器应当提示错误信息。

  - 服务器需要前端发送GET请求，那前端就应该发送GET请求，若发送POST请求，服务器应当提示错误信息。

- 怎么完成以上需求？

  - 在javaweb程序中想办法获取该请求是什么类型的请求，POST？还是GET？

  - 当我们获取到请求方式之后，在javaweb程序中可以使用java语言中if语句进行判断

- 怎么在javaweb程序中获取请求方式？

  - **重点：**HTTP的请求协议全部信息被自动封装到javax.servlet.http.HttpServletRequest对象中
  - 在HttpServletRequest接口类型中有一个方法叫做：String getMethod();可以获取请求方式
  - **public interface** javax.servlet.http.HttpServletRequest **extends** ServletRequest{}

- 在每一个Servlet类中都编写了程序，来保证前端的请求方式和后台需要的请求方式一致。但这些代码对每一个类都要编写，怎么能封装一下？

  - 编写一个Servlet类应当继承 javax.servlet.http.HttpServlet，get请求重写 doGet方法，post请求重写doPost方法，doGet/doPost方法可以等同看作main方法

    当浏览器发送的请求方式和后台的处理方式不同的话，会出现一个错误，代号405



### ④、面试官：你知道模板方法设计模式吗？在项目中哪里见过？

Servlet规范中的：**HttpServlet**

HttpServlet是一个典型的模板方法设计模式

HttpServlet是一个模板类，其中的service(HttpServletRequest, HttpServletResponse)方法是典型的模板方法，在该方法中定义了核心算法骨架，doGet，doPost...具体的实现步骤延迟到子类中完成。



**模板方法设计模式的特点：**

- doXXX
- doYYY

模板方法设计模式属于：行为型设计模式

模板方法设计模式主要作用：

1. 核心算法得到保护
2. 核心算法得到复用
3. 在不改变算法的前提下，却可以重新定义算法步骤的具体实现





## 6、Session与Cookie？

### Cookie

#### ①、Cookie是什么？Cookie作用？

翻译过来：曲奇饼干

Cookie可以保存会话状态，但是这个会话状态是保留在客户端上

只要Cookie清除，或者Cookie失效，这个会话状态就没有了

Cookie是保存在浏览器客户端上的

Cookie可以保存在浏览器缓存中，浏览器关闭Cookie消失

Cookie也可以保存在客户端的硬盘文件中，浏览器关闭Cookie还在，除非Cookie失效

#### ②、Cookie只是在javaweb中有吗？

Cookie不止是在javaweb中存在

只要是web开发，只要是B/S架构的系统，只要是基于HTTP协议，就有Cookie的存在

Cookie这种机制是HTTP协议规定的

#### ③、Cookie实现的功能，常见的有哪些？

保留购物车商品的状态在客户端上

十天内免登录

......

**在Java中Cookie被当作类来处理，使用new运算符可以创建Cookie对象，而且Cookie由两部分组成，分别是Cookie的name和value，name和value都是字符串类型String**

#### ④、在Java程序中怎么创建Cookie？

```java
Cookie cookie = new Cookie(String cookieName, String cookieValue);
```

服务器可以一次向浏览器发送多个Cookie

默认情况下，服务器发送Cookie给浏览器之后，浏览器将Cookie保存在缓存当中，只要不关闭浏览器，Cookie永远存在并且有效。当浏览器关闭后，缓存中的Cookie被清除

#### ⑤、在浏览器客户端无论是硬盘中还是缓存中保存的Cookie，什么时候会再次发送给服务器呢？

浏览器会不会提交发送这些Cookie给服务器，和请求路径有关

请求路径和Cookie是紧密关联的

不同的请求路径会发送提交不同的Cookie

#### ⑥、默认情况下Cookie会和哪些路径绑定在一起？

```java
/webapp/test/createAndSendCookieToBrowser
```

请求服务器，服务器生成Cookie，并将Cookie发送给浏览器客户端

这个浏览器中的Cookie会默认和“test/”这个路径绑定在一起

也就是说，以后只要发送”test/“请求，Cookie一定会提交给服务器。



```java
/webapp/test
```

请求服务器，服务器生成Cookie，并将Cookie发送给浏览器客户端

这个浏览器中的Cookie会默认和“webapp/”这个路径绑定在一起

也就是说，以后只要发送”webapp/“请求，Cookie一定会提交给服务器。

**其实路径是可以指定的，可以通过Java程序进行设置，保证Cookie和某个特定的路径绑定在一起。**

**假设执行了这样的程序：cookie.setPath("/prj-servlet-18/king");**那么Cookie将和“/prj-servlet-18/king”路径绑定在一起，只有发送这个请求路径，浏览器才会提交Cookie给服务器



**默认情况下，没有设置Cookie的有效时长，该Cookie被默认保存在浏览器的缓存当中，只要浏览器不关闭Cookie存在，只要关闭浏览器Cookie消失，我们可以通过设置Cookie的有效时长，以保证Cookie保存在硬盘文件当中，但是这个有效时长必须是>0。换句话说，只要设置Cookie的有效时长大于0，则该Cookie会被保存在客户端硬盘文件当中。有效时长过去之后，则硬盘当中的Cookie失效。**

```java
cookie.setMaxAge();//秒s
```

- Cookie有效时长 = 0 直接被删除
- Cookie有效时长 < 0 不会被存储
- Cookie有效时长 > 0 存储在硬盘文件当中

#### ⑦、服务器怎么接受Cookie？

```java
Cookie[] cookies = request.getCookies();
if(cookies != null){
    for(Cookie cookie : cookies){
        String cookieName = cookie.getName();
        String cookieValue = cookie.getValue();
        System.out.println(cookieName + "=" + cookieValue);
    }
}
```

#### ⑧、浏览器是可以禁用Cookie，什么意思？

表示服务器发送过来的Cookie，我浏览器不要，不接受

服务器还是会发送Cookie的，只是浏览器不接收。

#### 9⃣️、cookie怎么保证安全

- 服务器设置cookie的时候**设置HttpOnly属性**，可以防止客户端JavaScript的访问
- 服务器**设置安全标志Secure**，之后如果是HTTP连接，cookie将不会被发送

### Session

#### ①、Session是什么？

Session表示会话，不止是在javaweb中存在，只要是web开发，都有会话这种机制

在java中会话对应的类型是：javax.servlet.http.HttpSession，简称session/会话

Cookie可以将会话状态保存在客户端，HttpSession可以将会话状态保存在服务器端

#### ②、HttpSession

HttpSession对象是一个会话级别的对象，一次会话对应一个HttpSession对象

```java
HttpSession session = request.getSession();
```

什么是一次会话？

- “目前“可以这样理解：用户打开浏览器，在浏览器上发送多次请求，直到最终关闭浏览器，表示一次完整的会话

在会话进行过程中，web服务器一直为当前这个用户维护着一个会话对象/HttpSession

在WEB容器中，WEB容器维护了大量的HttpSession对象，换句话说，在WEB容器中应该有一个”Session列表“

**思考：**为什么当前会话中每一次请求可以获取到属于自己的会话对象？Session的实现原理？

- 打开浏览器，在浏览器上发送首次请求
- 服务器会创建一个HttpSession对象，该对象代表一次会话
- 同时生成HttpSession对象对应的Cookie对象，并且Cookie对象的name是JSESSIONID，Cookie的value是32位长度的字符串
- 服务器将Cookie的value和HttpSession对象绑定到session列表中
- 服务器将Cookie完整发送给浏览器客户端
- 浏览器客户端将Cookie保存到缓存中
- 只要浏览器不关闭，Cookie不会消失
- 当再次发送请求的时候，会自动提交缓存当中的Cookie
- 服务器接收到Cookie，验证该Cookie的name确实是：JSESSIONID，然后获取该Cookie的value（和HttpSession对象关联的这个Cookie的name是比较特殊的，在java中就叫做：JSESSIONID）
- 通过Cookie的value去session列表中检索对应的HttpSession对象

![Snipaste_2020-09-22_11-10-52](D:\JavaHub\学习相关\Java笔记\pictures\Snipaste_2020-09-22_11-10-52.png)

#### ③、浏览器禁用Cookie会出现什么问题？怎么解决？

- 浏览器禁用Cookie，则浏览器缓存中不再保存Cookie

- 导致在同一个会话中，无法获取到对应的会话对象

- 禁用Cookie之后，每一次获取的会话对象都是新的

- 浏览器禁用Cookie后，若还想拿到对应的Session对象，必须使用**URL重写机制**，怎么重写URL？

  - ```java
    https://www.bilibili.com;jsessionid=xxxxxxxxx
    ```

  - 重写URL会给编程带来难度/复杂度，所以一般的web站点是不建议禁用Cookie的。建议浏览器开启Cookie

#### ④、浏览器关闭之后，服务器端对应的Session对象会被销毁吗？为什么？

- 浏览器关闭之后，服务器不会销毁session对象
- 因为B/S架构的系统基于HTTP协议，而HTTP协议是一种无连接/无状态的协议
- 什么是无连接/无状态？
  - 请求的瞬间浏览器和服务器之间的通道打开，请求响应结束之后，通道关闭
  - 这样做的目的是降低服务器的压力

#### ⑤、session对象在什么时候被销毁？

- web系统中引入了session超时的概念

- 当很长一段时间(这个时间可以配置)没有用户再访问该session对象，此时session对象超时，web服务器自动回收session对象。

- 可配置：web.xml文件中，默认是30分钟

  ```xml
  <session-config>
  	<session-timeout>120</session-timeout>
  </session-config>
  ```

#### ⑥、到底什么是一次会话？

- 一般多数情况下，这样描述：用户打开浏览器，在浏览器上进行一些操作，然后将浏览器关闭，表示一次会话结束
- 本质上的描述：从session对象的创建，到最终session对象超时之后销毁，这个才是真正意义的一次完整会话



### Cookie和Session区别

- Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案。
- 第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，客户端请求服务器时会将Cookie一起提交，每次请求把这个会话ID发送到服务器，服务器就知道客户端是谁。
- Session保存在服务端，运行依赖Sessionid。保存Sessionid的方式可以采用Cookie。如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。
- 用户验证这种场合一般会用 session，因此，维持一个会话的核心就是客户端的唯一标识，即 session id。
- cookie长度有限制，最多cookie条数chrome是150，单个cookie长度4059字节，session没有

## 7、从输入网址到获得页面的过程 (越详细越好)？

第一步，浏览器输入域名后，主机需要去解析域名的IP地址。首先查找本地浏览器DNS缓存、操作系统DNS缓存等是否有当前域名的IP地址，如果没有的话需要去找本地DNS服务器进行解析。如果DNS服务器也没有缓存当前域名，就需要DNS服务器向根域名服务器查询IP地址，这里会用到迭代查询或者递归查询。如果向本地服务器查询，本地DNS服务器会递归对顶级DNS服务器查询。顶级服务器会迭代向其他顶级域名DNS服务器进行查询。如果任何一个过程中查询到了IP地址就返回给主机。

第二步，主机拿到域名解析过的IP地址后，浏览器就向服务器发出连接请求，进行三次握手连接。

第三步，浏览器和服务器建立连接后，浏览器向服务器发送http请求。

第四步，服务器接收到请求后，查找出index.jsp对应的index.class编译文件，通过jvm运行index.class得到运行结果，将处理结果返回给浏览器。

第五步，浏览器根据返回的结果进行解析并渲染，如果遇到CSS、js、图片文件等静态资源的引用，重复上述过程。

第六步，拿到所有结果后浏览器渲染完成。

## 8、HTTP请求有哪些常见状态码？

1. 2xx状态码：操作成功。200 OK
2. 3xx状态码：重定向。301 永久重定向；302暂时重定向
3. 4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；
4. 5xx状态码：服务端错误。**500**服务器内部错误；**501**服务不可用；**502**作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。；**504**作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应

## 9、什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？

RIP是应用层协议。

每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。

## 10、HTTP1.0、1.1、2.0和3.0区别

1.1和1.0的区别：

1 缓存处理

2 带宽优化及网络连接的使用（HTTP1.0中，存在一些浪费带宽的现象	）

3 错误通知的管理（在HTTP1.1中新增了24个错误状态响应码）

4 消息在网络中的发送

5 Host头处理（在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request））

6 安全性及完整性

7 长链接



2.0和1.x区别：

- **多路复用 (Multiplexing)**：每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
- **二进制分帧**：HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮
- **首部压缩（Header Compression）**：如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
- **服务端推送（Server Push）**：例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。



3.0和2.0区别：

- **多路复用：**HTTP2.0基于TCP协议，具有可靠传输特性，如果有数据包丢失，会阻塞其后面的数据传输。HTTP3.0的QUIC基于UDP协议，非可靠传输，可以实现不同流之间的独立。
- **加密认证的报文：**TCP协议头部没有经过任何加密认证，在传输过程中有可能会被篡改。3.0的QUIC除了个别报文，所有报文头都经过认证了，报文body进行了加密。
- **向前纠错机制：**QUIC协议的数据包出了它本身的内容外，还包括了其他数据包的数据，所以如果有少量的丢包可以通过其他包的数据直接组装不需要重传。当然这里也牺牲了每个数据包可以发送数据的上限，但带来的提升大于丢包导致的数据重传。



## 11、如何防范XSS（跨站脚本攻击）攻击

XSS攻击三种类型

- 存储型XSS
  - 攻击者将恶意代码提交到目标网站的数据库中。
  - 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
  - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
  - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
- 反射型XSS
  - 攻击者构造出特殊的 URL，其中包含恶意代码。
  - 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
  - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
  - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
- DOM型XSS
  - 攻击者构造出特殊的 URL，其中包含恶意代码。
  - 用户打开带有恶意代码的 URL。
  - 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
  - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

区别：

- 反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在**数据库**里，反射型 XSS 的恶意代码存在 **URL** 里。
- DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由**浏览器端**完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于**服务端**的安全漏洞。

XSS攻击的两大要素：

- 攻击者提交恶意代码
- 浏览器执行恶意代码

XSS攻击的预防：

- 防范攻击者提交恶意代码

  - 输入过滤，对明确的输入类型，如电话号码、邮件地址等等。

- 防范浏览器执行恶意代码

  - 纯前端渲染，把代码和数据分隔开

    1. 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。
    2. 然后浏览器执行 HTML 中的 JavaScript。
    3. JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。

  - 对HTML做充分转义

    如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。

  - 修改JavaScript代码，变得严谨

    在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 `.textContent`、`.setAttribute()` 等。

# 二、网络层

## 1、划分子网

从主机号host-id借用若干个比特作为子网号subnet-id；子网掩码：网络号和子网号都为1，主机号为0；数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网：将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。

**路由设置指令：**

```
route add –net 172.16.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1
```

表示：添加目标网段为172.16.1.0，子网掩码为255.255.255.0，下一跳地址是192.168.1.1，跃点数为1的路由

## 2、ARP协议

**ARP协议完成了IP地址与物理地址的映射**。每一个主机都设有一个 ARP 高速缓存，里面有**所在的局域网**上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有，就向**所在的局域网**发起一个ARP请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。

如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。

## 3、NAT(Network Address Translation, 网络地址转换)

用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。

# 三、传输层

## 0、TCP状态机

![img](https://upload-images.jianshu.io/upload_images/2846604-6a8557619966204d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

## 1、三次握手

- 第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入**SYN_SENT**状态；
- 第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入**SYN_RCVD**状态；
- 第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入**ESTABLISHED**状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入**ESTABLISHED**状态；完成三次握手，连接建立。

### ①TCP建立连接可以两次握手吗？为什么?

不可以。有两个原因：

- 首先，可能会出现**已失效的连接请求报文段又传到了服务器端**。client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。
- 其次，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。

### ②可以采用四次握手吗？为什么？

可以。但是会降低传输的效率。

四次握手是指：第二次握手：Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并。

### ③第三次握手中，如果客户端的ACK未送达服务器，会怎样？

Server端：
由于Server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。

Client端，两种情况：

1. 在Server进行超时重发的过程中，如果Client向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取 ACK number，进入 establish 状态
2. 在Server进入CLOSED状态之后，如果Client向服务器发送数据，服务器会以RST包应答。

### ④如果已经建立了连接，但客户端出现了故障怎么办？

服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### ⑤初始序列号是什么？

TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002...三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。

## 2、四次挥手

- 第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入**FIN_WAIT_1**状态；
- 第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入**CLOSE_WAIT**状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。
- 第三次挥手：Server将FIN置1，发送一个序列号给Client；进入**LAST_ACK**状态；
- 第四次挥手：Client收到服务器的FIN后，进入**TIME_WAIT**状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为**CLOSED**状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。

### ①为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？

因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。

### ②如果第二次挥手时服务器的ACK没有送达客户端，会怎样？

客户端没有收到ACK确认，会重新发送FIN请求。

### ③客户端TIME_WAIT状态的意义是什么？

- 第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。

  MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

- 允许旧的重复数据段在网络中过期。此连接关闭后，在相通的地址和端口建立了另外一个连接。由于IP地址和端口相同，所以后一种连接被称为先前连接的“化身”。TCP必须防止连接中的旧副本在稍后再次出现，并被误解为属于同一连接的新“化身”。

## 3、TCP如何实现流量控制？

使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。

发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。

### ①什么是零窗口（接收窗口为0时会怎样）？

如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。

## 4、TCP的拥塞控制是怎么实现的？

拥塞控制主要由四个算法组成：**慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）**

- **慢启动（Slow Start）**

  刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍

- **拥塞避免（Congestion voidance）**

  当拥塞窗口的大小达到慢开始门限(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS.

  > 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。**（这是不使用快重传的情况）**

- **快重传 （Fast Retransmit）**

  快重传要求接收方在收到一个失序的报文段后就立即发出**重复确认**（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

- **快恢复（Fast Recovery）**

  当发送方连续收到三个重复确认时，就把慢开始门限设置为当前窗口值一半，窗口值等于慢开始门限，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。
也有的快重传是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3*MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中减少了三个分组。因此可以适当把拥塞窗口扩大些。## 5、TCP与UDP的区别



## 5、TCP与UDP的区别

1. TCP是面向连接的，UDP是无连接的；

   > UDP发送数据之前不需要建立连接,TCP虚电路

2. TCP是可靠的，UDP不可靠；

   > UDP接收方收到报文后，不需要给出任何确认

3. TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；

4. TCP是面向字节流的，UDP是面向报文的；

   > 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。

5. TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；

6. TCP首部开销（20字节）比UDP首部开销（8字节）要大

7. UDP 的主机不需要维持复杂的连接状态表

### ①什么时候选择TCP，什么时候选UDP？

对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失

### ②HTTP可以使用UDP吗？

HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠

### ③面向连接和无连接的区别

无连接的网络服务（数据报服务）-- 面向连接的网络服务（虚电路服务）

虚电路服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证；

数据报服务：每个数据包含目的地址，数据路由相互独立（路径可能变化）；网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃；



## 6、TCP如何保证传输的可靠性

1. 数据包校验
2. 对失序数据包重新排序（TCP报文具有序列号）
3. 丢弃重复数据
4. 应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；
5. 超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；
6. 流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出



## 7、数据链路层和传输层可靠传输区别

数据链路层是为保证物理层传输可靠，因为物理层可能导致比特传输差错，数据链路层保证向上层提供的数据是无差错的；传输层是为保证网络层可靠传输，因为数据报在核心网传输过程中，可能会在路由器那里因负载过高导致丢弃，然后传输层重传，来保证可靠传输，这样传输层能保证向上层(也就是应用层)提供的数据是无误且按序交付的。



## 8、OSI七层模型各层代表协议

物理层：RJ45、CLOCK、IEEE802.3

数据链路：PPP、FR、HDLC、VLAN、MAC

网络层：**IP、ICMP(用于在IP主机、路由器之间传递控制消息)、ARP(根据IP地址获取物理地址)**、RARP、OSPF、IPX、**NAT**、IGRP

传输层：TCP、UDP、SPX

会话层：NFS、SQL、NETBIOS、RPC

表示层：JPEG、MPEG、ASII、MP4

应用层：**FTP、DNS、RIP**、Telnet、SMTP、**HTTP**、WWW、NFS



**七层模型的浏览器执行过程**

客户端浏览器首先获取本地host文件获取IP，如果获取不到再通过DNS解析到[www.baidu.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.baidu.com) 的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。

客户端浏览器发起一个HTTP会话到220.181.27.48，通过TCP握手建立连接，然后通过TCP进行封装数据包，输入到网络层。

在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。

然后使用IP层的IP地址查找目的端。客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器。

期间可能经过多个路由器，这些都是由路由器来完成的工作，无非就是通过查找路由表决定通过那个路径到达服务器。

客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址。

然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

服务器处理请求后响应首页数据反向传输，传输到客户端后，TCP连接释放，浏览器将首页文件进行解析，并将Web页显示给用户。	