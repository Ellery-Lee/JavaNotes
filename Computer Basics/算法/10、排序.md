# 排序算法

内部排序：指将需要处理的所有数据都加载到内部存储器中进行排序。

外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。

## 常见的排序算法分类

![img](https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200619194904.png)

### 时间频度和时间复杂度

**时间频度T(n)**

一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中**语句的执行次数成正比例**，哪个算法中语句执行次数多，它花费时间就多。**一个算法中的语句执行次数称为语句频度或时间频度**。记为T(n)。

**时间复杂度O(n)**

一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。

在T(n)=4n²-2n+2中，就有f(n)=n²，使得T（n)/f(n)的极限值为4，那么O(f(n))，也就是时间复杂度为O(n²)

- 对于不是只有常数的时间复杂度**忽略时间频度的系数、低次项常数**
- 对于只有常数的时间复杂度，将常数看为1
- ![img](https://www.runoob.com/wp-content/uploads/2019/03/sort.png)

### 1、冒泡排序

**算法步骤**

- 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，**最后的元素会是最大的数**。
- 针对所有的元素重复以上的步骤，**除了最后一个**。
- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
- 一共进行了**数组元素个数-1**次大循环，且每次大循环中需要比较的元素越来越少。
- 优化：如果在某次大循环，发现没有发生交换，则证明已经有序。
- 优点：稳定

```java
public class Bubble<T extends Comparable<T>> extends Sort<T> {

    @Override
    public void sort(T[] nums) {
        int N = nums.length;
        boolean isSorted = false;
        //注意这里从N-1开始，确定了右边界
        for (int i = N - 1; i > 0 && !isSorted; i--) {
            isSorted = true;
            for (int j = 0; j < i; j++) {
                if (less(nums[j + 1], nums[j])) {
                    isSorted = false;
                    swap(nums, j, j + 1);
                }
            }
        }
    }
}
```

### 2、选择排序

**算法步骤**

- 遍历整个数组，找到最小（大）的元素，放到数组的起始位置。
- 再遍历剩下的数组，找到剩下元素中的最小（大）元素，放到数组的第二个位置。
- 重复以上步骤，直到排序完成。
- 一共需要遍历数组元素个数n-1次，当找到第二大（小）的元素时，可以停止。这时最后一个元素必是最大（小）元素。
- 缺点：不稳定，有可能会破坏元素相对顺序

```java
public class Selection<T extends Comparable<T>> extends Sort<T> {

    @Override
    public void sort(T[] nums) {
        int N = nums.length;
        for (int i = 0; i < N - 1; i++) {
            int min = i;
            for (int j = i + 1; j < N; j++) {
                if (less(nums[j], nums[min])) {
                    min = j;
                }
            }
            swap(nums, i, min);
        }
    }
}
```

### 3、插入排序

**算法步骤**

- 将待排序序列第一个元素看做一个**有序序列**，把第二个元素到最后一个元素当成是**未排序序列**。
- 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。
- 优点：稳定

```java
class Solution {
    public int[] sortArray(int[] nums) {
        int n = nums.length;
        for(int i = 1; i < nums.length; i++){
            int temp = nums[i];
            int j = i;
            while(j > 0 && nums[j-1] > temp){
                nums[j] = nums[j-1];
                j--;
            }
            nums[j] = temp;
        }
        return nums;
    }
}
```

### 4、希尔排序

**回顾：插入排序存在的问题**

当最后一个元素为整个数组的最小元素时，需要将前面的有序数组中的每个元素都向后移一位，这样是非常花时间的。

所以有了希尔排序来帮我们将数组从无序变为整体有序再变为有序。

优点：时间复杂度低

缺点：不稳定

**算法步骤**

- 选择一个增量序列t1（一般是数组长度/2），t2（一般是一个分组长度/2），……，tk，**其中 ti > tj**, tk = 1；
- 按增量序列个数 k，对序列进行 k 趟排序；
- 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

### 5、快速排序

**算法步骤**

- 从数列中挑出一个元素，称为 “基准”（pivot）
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序

```java
public void quickSort(int[] arr, int low, int high){
    //终止条件
    if(low >= high){
        return;
    }
    //左指针
    int left = low;
    //右指针
    int right = high;
    //pivot参考值，这里选取第一个元素
    int pivotValue = arr[low];
    while(left < right){
        //右指针左移
        while(left < right && arr[right] >= pivotValue){
            right--;
        }
        //左指针右移
        while(left < right && arr[left] <= pivotValue){
            left++;
        }
        //此时两指针指向元素都不满足规则(arr[left] > pivotValue && arr[right] < pivotValue)或者left==right，交换两指针
        swap(arr, left, right);
    }
    //把pivotValue值放入分界点
    swap(arr, low, left);
    quickSort(arr, low, left - 1);
    quickSort(arr, left + 1, high);
}

public void swap(int[] arr, int i, int j){
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

**快速排序优化：**

- 优化选取枢轴
  - 原序列可能是有序的，如果固定选取第一个作为pivot会影响性能，比如逆序情况下
  - 解决方法：三数取中、九数取中等
- 优化不必要的交换
  - 采用替换而不是交换的方式进行操作，见《大话数据结构》P424
- 优化小数组时的排序方案
  - **如果数组非常小，采用插入排序的方法，因为快排递归影响性能，大炮打蚊子**
  - 数组大，采用快速排序，临界值：7或15
- 优化递归操作
  - 尾递归，缩减栈深度

### 6、归并排序

**算法步骤**

归并排序用到了**分而治之**的思想，其难点是**治**

- 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
- 设定两个指针，最初位置分别为两个已经排序序列的起始位置
- 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
- 重复上一步 直到**某一指针达到序列尾**
- 将另一序列剩下的所有元素直接复制到合并序列尾

### 7、基数排序

**算法步骤**

- 将所有待比较数值（正整数）统一为同样的数位长度，**数位较短的数前面补零**
- 从最低位开始，依次进行一次排序
- 从最低位排序一直到最高位（个位->十位->百位->…->最高位）排序完成以后, 数列就变成一个有序序列
- 需要我们获得最大数的位数
  - 可以通过将**最大数变为String类型**，再求得它的长度即可

### 8、堆排序

**基本介绍**

- 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为 **O(nlogn)**，它也是不稳定排序

- 堆是具有以下性质的**完全二叉树**：

  - 每个结点的值都大于或等于其左右孩子结点的值，称为

    大顶堆

    - **注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。**大根堆特点：nums[i]>=nums[2*i=1] && nums[i]>=nums[2*i+2];

  - 每个结点的值都小于或等于其左右孩子结点的值，称为**小顶堆**

- 一般升序排序采用大顶堆，降序排列使用小顶堆



## 快排和归并的区别：

快排的思想是在区间`[i,j]`内随机选取一个标兵`pivot`然后将比标兵小的放在左边，大的放在右边。之后重复对子区间进行相同的操作直到区间内元素的个数为1，也就是`i == j`。归并排序的思想是先将数组分成许多只有一个元素的小份，然后再把它们两两合并直到最后合成一个完整的排序好的数组。合并的前提是参与合并的两个数组都是有序的并且合并出来的数组也得是有序的。
在快排中真正“排序”的过程发生在将一个大的区间分为两个小的区间时，而归并排序则发生在将两个小区间合成为一个大区间。但两者都可以用递归的方式来实现。此外，由于快排中标兵的选取是随机的，如果标兵恰好选择了区间中最小的数，则快排的时间复杂度上升为 O(n^2^)